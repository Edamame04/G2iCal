<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PROJECT_STRUCTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PROJECT_STRUCTURE.md" />
              <option name="originalContent" value="# Google Calendar to iCal Converter - Project Structure Documentation&#10;&#10;## Project Overview&#10;A Java application that exports Google Calendar events to iCal format (.ics files) using object-oriented design principles and patterns.&#10;&#10;## Architecture Overview&#10;&#10;```&#10;google_calendar_iCal/&#10;├── src/main/java/&#10;│   ├── calendar.ICal.java                    # Main iCal container class&#10;│   ├── G2iCal.java                 # Command-line interface&#10;│   ├── calendar/                    # Domain objects package&#10;│   │   ├── CalendarEvent.java       # Event interface (abstraction)&#10;│   │   ├── MyEvent.java            # Concrete event implementation&#10;│   │   └── MyEventBuilder.java     # Builder pattern for event creation&#10;│   ├── exceptions/                  # Custom exception handling&#10;│   │   └── ICalExportException.java # Export-specific exceptions&#10;│   └── utils/                       # Utility classes package&#10;│       ├── CalendarApiConnector.java # Google Calendar API integration&#10;│       ├── EventConverter.java      # Event conversion logic&#10;│       ├── EventFactory.java       # Factory pattern for event creation&#10;│       └── InputValidator.java      # Input validation utilities&#10;├── src/main/resources/&#10;│  └── credentials.json             # Google API credentials&#10;└── tokens                          # Token storage for Google API&#10;```&#10;&#10;## Object-Oriented Design Patterns Implemented&#10;&#10;### 1. **Interface Segregation Principle**&#10;- **`CalendarEvent` Interface**: Defines contract for all calendar events&#10;- **Benefits**: Allows different event implementations, improves testability&#10;&#10;### 2. **Factory Pattern**&#10;- **`EventFactory`**: Centralized creation of CalendarEvent objects&#10;- **Methods**:&#10;  - `createFromGoogle(Event)`: Creates events from Google Calendar API&#10;  - `createFromData(...)`: Creates events from raw data&#10;- **Benefits**: Encapsulates object creation, easy to extend for new event types&#10;&#10;### 3. **Builder Pattern**&#10;- **`MyEventBuilder`**: Fluent API for constructing complex MyEvent objects&#10;- **Benefits**: Readable code, handles optional parameters, immutable object creation&#10;&#10;### 4. **Singleton Pattern**&#10;- **`CalendarApiConnector`**: Single instance for Google API connections&#10;- **Benefits**: Resource management, consistent authentication state&#10;&#10;### 5. **Custom Exception Handling**&#10;- **`ICalExportException`**: Specific exceptions for export operations&#10;- **Benefits**: Clear error handling, better debugging information&#10;&#10;## Class Responsibilities&#10;&#10;### Core Classes&#10;&#10;#### `calendar.ICal.java`&#10;**Purpose**: Main container for iCalendar data and export functionality&#10;**Key Responsibilities**:&#10;- Store collection of CalendarEvent objects&#10;- Generate iCal formatted strings&#10;- Export to .ics files&#10;- Handle export exceptions&#10;&#10;**Key Methods**:&#10;```java&#10;public void addGoogleEvent(Event event)           // Add Google Calendar event&#10;public String getICalString()                     // Generate iCal format&#10;public boolean exportICalToFile(String, String)  // Export to file&#10;```&#10;&#10;#### `G2iCal.java`&#10;**Purpose**: Command-line interface and application entry point&#10;**Key Responsibilities**:&#10;- Parse command-line arguments&#10;- Handle user interaction&#10;- Coordinate between API and export functionality&#10;- Manage application flow and error handling&#10;&#10;### Domain Package (`calendar/`)&#10;&#10;#### `CalendarEvent.java` (Interface)&#10;**Purpose**: Define contract for all calendar events&#10;**Methods**:&#10;```java&#10;String getUid(), getSummary(), getDescription(), getLocation()&#10;LocalDateTime getStart(), getEnd()&#10;String getOrganizer()&#10;List&lt;String&gt; getAttendees()&#10;String toICal()  // Convert to iCal format&#10;```&#10;&#10;#### `MyEvent.java`&#10;**Purpose**: Concrete implementation of calendar events&#10;**Key Features**:&#10;- Implements `CalendarEvent` interface&#10;- Stores all event data (UID, summary, description, location, times, organizer, attendees)&#10;- Provides iCal formatting logic&#10;- Includes getter/setter methods&#10;&#10;#### `MyEventBuilder.java`&#10;**Purpose**: Builder pattern for creating MyEvent objects&#10;**Usage Example**:&#10;```java&#10;MyEvent event = new MyEventBuilder()&#10;    .setUid(&quot;123&quot;)&#10;    .setSummary(&quot;Meeting&quot;)&#10;    .setStart(startTime)&#10;    .setEnd(endTime)&#10;    .build();&#10;```&#10;&#10;### Utilities Package (`utils/`)&#10;&#10;#### `EventConverter.java`&#10;**Purpose**: Convert Google Calendar Event objects to CalendarEvent objects&#10;**Key Features**:&#10;- Static utility methods&#10;- Handles date/time conversion&#10;- Extracts organizer and attendee information&#10;- Returns CalendarEvent interface (not concrete class)&#10;&#10;#### `EventFactory.java`&#10;**Purpose**: Factory for creating CalendarEvent instances&#10;**Key Features**:&#10;- Centralizes object creation logic&#10;- Uses EventConverter internally&#10;- Provides multiple creation methods&#10;- Returns interface types for flexibility&#10;&#10;#### `CalendarApiConnector.java`&#10;**Purpose**: Singleton for Google Calendar API integration&#10;**Key Features**:&#10;- Manages authentication&#10;- Provides calendar listing&#10;- Fetches events by date range&#10;- Handles API-specific exceptions&#10;&#10;#### `InputValidator.java`&#10;**Purpose**: Validate user inputs and command-line arguments&#10;**Key Features**:&#10;- Date format validation&#10;- Calendar index validation&#10;- Filename validation&#10;- Returns ValidationResult objects&#10;&#10;### Exceptions Package (`exceptions/`)&#10;&#10;#### `ICalExportException.java`&#10;**Purpose**: Custom exception for export-related errors&#10;**Key Features**:&#10;- Extends Exception (checked exception)&#10;- Provides specific error context&#10;- Wraps underlying IO exceptions&#10;&#10;## Design Principles Applied&#10;&#10;### 1. **Single Responsibility Principle (SRP)**&#10;- Each class has one clear purpose&#10;- EventConverter only handles conversion&#10;- InputValidator only handles validation&#10;- calendar.ICal only handles iCal operations&#10;&#10;### 2. **Open/Closed Principle (OCP)**&#10;- CalendarEvent interface allows new event types without modifying existing code&#10;- Factory pattern allows new creation methods&#10;- Strategy pattern ready for different export formats&#10;&#10;### 3. **Dependency Inversion Principle (DIP)**&#10;- calendar.ICal depends on CalendarEvent interface, not concrete MyEvent&#10;- EventFactory returns interfaces, not concrete classes&#10;- Easier testing with mock implementations&#10;&#10;### 4. **Interface Segregation Principle (ISP)**&#10;- CalendarEvent interface contains only necessary methods&#10;- No forced implementation of unused methods&#10;&#10;### 5. **Don't Repeat Yourself (DRY)**&#10;- EventConverter centralizes conversion logic&#10;- InputValidator centralizes validation logic&#10;- Factory pattern centralizes creation logic&#10;&#10;## Data Flow&#10;&#10;```&#10;1. User Input → G2iCal&#10;2. G2iCal → CalendarApiConnector (fetch calendars)&#10;3. G2iCal → CalendarApiConnector (fetch events)&#10;4. Google Events → EventFactory → CalendarEvent objects&#10;5. CalendarEvent objects → calendar.ICal container&#10;6. calendar.ICal → Generate iCal string → Export to file&#10;```&#10;&#10;## Extension Points&#10;&#10;### Easy to Add:&#10;1. **New Event Types**: Implement CalendarEvent interface&#10;2. **New Export Formats**: Strategy pattern for exporters&#10;3. **New Input Sources**: Factory pattern for event creation&#10;4. **New Validation Rules**: Extend InputValidator&#10;5. **New Exception Types**: Custom exception hierarchy&#10;&#10;### Future Enhancements:&#10;- **Observer Pattern**: Progress notifications during export&#10;- **Command Pattern**: CLI command objects&#10;- **Strategy Pattern**: Multiple export formats (JSON, XML)&#10;- **Template Method**: Different calendar provider integrations&#10;&#10;## Testing Strategy&#10;&#10;### Unit Testing Ready:&#10;- Interface-based design allows easy mocking&#10;- Factory pattern isolates object creation&#10;- Single responsibility makes testing focused&#10;- Custom exceptions provide specific test scenarios&#10;&#10;### Integration Testing:&#10;- CalendarApiConnector can be mocked for API testing&#10;- File export can be tested with temporary directories&#10;- End-to-end testing through G2iCal&#10;&#10;## Benefits of Current Structure&#10;&#10;1. **Maintainability**: Clear separation of concerns&#10;2. **Extensibility**: Easy to add new features&#10;3. **Testability**: Interface-based design&#10;4. **Reusability**: Utility classes can be reused&#10;5. **Error Handling**: Specific exceptions for different scenarios&#10;6. **Code Quality**: Follows OOP principles and design patterns&#10;&#10;## Dependencies&#10;&#10;- **Google Calendar API**: For calendar integration&#10;- **Java Time API**: For date/time handling&#10;- **Java NIO**: For file operations&#10;- **Standard Java Collections**: For data structures&#10;" />
              <option name="updatedContent" value="# Google Calendar to iCal Converter - Project Structure Documentation&#10;&#10;## Project Overview&#10;A Java application that exports Google Calendar events to iCal format (.ics files) using object-oriented design principles and patterns. Built with Gradle as the build system.&#10;&#10;## Architecture Overview&#10;&#10;```&#10;google_calendar_iCal/&#10;├── build.gradle                     # Gradle build configuration&#10;├── settings.gradle.kts              # Gradle settings&#10;├── gradlew                          # Gradle wrapper script (Unix)&#10;├── gradlew.bat                      # Gradle wrapper script (Windows)&#10;├── PROJECT_STRUCTURE.md             # This documentation file&#10;├── test.ics                         # Sample iCal output file&#10;├── src/&#10;│   ├── main/&#10;│   │   ├── java/&#10;│   │   │   ├── G2iCal.java          # Command-line interface&#10;│   │   │   ├── calendar/            # Domain objects package&#10;│   │   │   │   ├── CalendarEvent.java    # Event interface (abstraction)&#10;│   │   │   │   ├── ICal.java             # Main iCal container class&#10;│   │   │   │   ├── MyEvent.java          # Concrete event implementation&#10;│   │   │   │   └── MyEventBuilder.java   # Builder pattern for event creation&#10;│   │   │   ├── exceptions/          # Custom exception handling&#10;│   │   │   │   └── ICalExportException.java # Export-specific exceptions&#10;│   │   │   └── utils/               # Utility classes package&#10;│   │   │       ├── CalendarApiConnector.java # Google Calendar API integration&#10;│   │   │       ├── EventConverter.java      # Event conversion logic&#10;│   │   │       ├── EventFactory.java       # Factory pattern for event creation&#10;│   │   │       └── InputValidator.java     # Input validation utilities&#10;│   │   └── resources/&#10;│   │       └── credentials.json     # Google API credentials&#10;│   └── test/&#10;│       ├── java/                    # Test source files&#10;│       └── resources/               # Test resources&#10;├── build/                           # Gradle build output directory&#10;│   ├── classes/&#10;│   │   └── java/&#10;│   │       └── main/                # Compiled Java classes&#10;│   ├── generated/                   # Generated source files&#10;│   ├── reports/                     # Build reports&#10;│   ├── resources/&#10;│   │   └── main/                    # Processed resources&#10;│   └── tmp/                         # Temporary build files&#10;├── gradle/&#10;│   └── wrapper/                     # Gradle wrapper files&#10;│       ├── gradle-wrapper.jar&#10;│       └── gradle-wrapper.properties&#10;└── tokens/                          # Token storage for Google API&#10;    └── StoredCredential&#10;```&#10;&#10;## Build System&#10;This project uses **Gradle** as the build system, providing:&#10;- Dependency management&#10;- Automated building and testing&#10;- Cross-platform build scripts (gradlew/gradlew.bat)&#10;- Integration with modern Java development workflows&#10;&#10;## Object-Oriented Design Patterns Implemented&#10;&#10;### 1. Builder Pattern&#10;- **Class**: `MyEventBuilder`&#10;- **Purpose**: Provides a fluent interface for constructing complex `MyEvent` objects&#10;- **Benefits**: Improves readability and handles optional parameters elegantly&#10;&#10;### 2. Factory Pattern&#10;- **Class**: `EventFactory`&#10;- **Purpose**: Creates appropriate event objects based on input parameters&#10;- **Benefits**: Encapsulates object creation logic and provides flexibility&#10;&#10;### 3. Interface Segregation&#10;- **Interface**: `CalendarEvent`&#10;- **Implementation**: `MyEvent`&#10;- **Purpose**: Defines contract for calendar events, allowing for future extensions&#10;&#10;## Package Structure&#10;&#10;### calendar/&#10;Contains the core domain objects representing calendar events and the iCal container.&#10;&#10;### exceptions/&#10;Houses custom exception classes for handling export-specific errors and validation failures.&#10;&#10;### utils/&#10;Utility classes that provide supporting functionality:&#10;- API connectivity&#10;- Data conversion&#10;- Input validation&#10;- Object creation&#10;&#10;## Key Features&#10;- Google Calendar API integration&#10;- iCal format export (.ics files)&#10;- Input validation and error handling&#10;- Modular, extensible design&#10;- Gradle build automation" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/EventConverter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/EventConverter.java" />
              <option name="originalContent" value="import com.google.api.client.util.DateTime;&#10;import com.google.api.services.calendar.model.Event;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.ZoneId;&#10;&#10;public class EventConverter {&#10;&#10;    public MyEvent convert(Event googleEvent) {&#10;        String uid = googleEvent.getId();&#10;        String summary = googleEvent.getSummary();&#10;        String description = googleEvent.getDescription();&#10;        String location = googleEvent.getLocation();&#10;        String organizer = googleEvent.getOrganizer() != null ? googleEvent.getOrganizer().getEmail() : null;&#10;        java.util.List&lt;String&gt; attendees = new java.util.ArrayList&lt;&gt;();&#10;        if (googleEvent.getAttendees() != null) {&#10;            for (Event.Attendee attendee : googleEvent.getAttendees()) {&#10;                attendees.add(attendee.getEmail());&#10;            }&#10;        }&#10;&#10;        DateTime startTime = googleEvent.getStart().getDateTime();&#10;        DateTime endTime = googleEvent.getEnd().getDateTime();&#10;        if (startTime == null) {&#10;            startTime = googleEvent.getStart().getDate();&#10;        }&#10;        if (endTime == null) {&#10;            endTime = googleEvent.getEnd().getDate();&#10;        }&#10;        LocalDateTime start = startTime.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();&#10;        LocalDateTime end = endTime.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();&#10;&#10;        return new MyEvent(uid, summary, description, location, start, end, organizer, attendees);&#10;    }&#10;}" />
              <option name="updatedContent" value="import com.google.api.services.calendar.model.Event;&#10;import com.google.api.services.calendar.model.EventAttendee;&#10;import com.google.api.client.util.DateTime;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.ZoneId;&#10;import java.util.Date;&#10;&#10;public class EventConverter {&#10;&#10;    public MyEvent convert(Event googleEvent) {&#10;        String uid = googleEvent.getId();&#10;        String summary = googleEvent.getSummary();&#10;        String description = googleEvent.getDescription();&#10;        String location = googleEvent.getLocation();&#10;        String organizer = googleEvent.getOrganizer() != null ? googleEvent.getOrganizer().getEmail() : null;&#10;        java.util.List&lt;String&gt; attendees = new java.util.ArrayList&lt;&gt;();&#10;        if (googleEvent.getAttendees() != null) {&#10;            for (EventAttendee attendee : googleEvent.getAttendees()) {&#10;                attendees.add(attendee.getEmail());&#10;            }&#10;        }&#10;&#10;        DateTime startTime = googleEvent.getStart().getDateTime();&#10;        DateTime endTime = googleEvent.getEnd().getDateTime();&#10;        if (startTime == null) {&#10;            startTime = googleEvent.getStart().getDate();&#10;        }&#10;        if (endTime == null) {&#10;            endTime = googleEvent.getEnd().getDate();&#10;        }&#10;        LocalDateTime start = LocalDateTime.ofInstant(new Date(startTime.getValue()).toInstant(), ZoneId.systemDefault());&#10;        LocalDateTime end = LocalDateTime.ofInstant(new Date(endTime.getValue()).toInstant(), ZoneId.systemDefault());&#10;&#10;        return new MyEvent(uid, summary, description, location, start, end, organizer, attendees);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/MyEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/MyEvent.java" />
              <option name="originalContent" value="public class MyEvent {&#10;    private String uid;&#10;    private String summary;&#10;    private String description;&#10;    private String location;&#10;    private java.time.LocalDateTime start;&#10;    private java.time.LocalDateTime end;&#10;    private String organizer;&#10;    private java.util.List&lt;String&gt; attendees;&#10;&#10;    public MyEvent(String uid, String summary, String description, String location, java.time.LocalDateTime start, java.time.LocalDateTime end, String organizer, java.util.List&lt;String&gt; attendees) {&#10;        this.uid = uid;&#10;        this.summary = summary;&#10;        this.description = description;&#10;        this.location = location;&#10;        this.start = start;&#10;        this.end = end;&#10;        this.organizer = organizer;&#10;        this.attendees = attendees;&#10;    }&#10;&#10;    public MyEvent() {&#10;        this.attendees = new java.util.ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // Create iCal format string for the event&#10;    public StringBuilder toICalString(StringBuilder sb) {&#10;        sb.append(&quot;BEGIN:VEVENT\n&quot;);&#10;        sb.append(&quot;UID:&quot;).append(uid).append(&quot;\n&quot;);&#10;        sb.append(&quot;SUMMARY:&quot;).append(summary).append(&quot;\n&quot;);&#10;        sb.append(&quot;DESCRIPTION:&quot;).append(description).append(&quot;\n&quot;);&#10;        sb.append(&quot;LOCATION:&quot;).append(location).append(&quot;\n&quot;);&#10;        sb.append(&quot;DTSTART:&quot;).append(start.format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd'T'HHmmss&quot;))).append(&quot;\n&quot;);&#10;        sb.append(&quot;DTEND:&quot;).append(end.format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd'T'HHmmss&quot;))).append(&quot;\n&quot;);&#10;        sb.append(&quot;ORGANIZER:&quot;).append(organizer).append(&quot;\n&quot;);&#10;        for (String attendee : attendees) {&#10;            sb.append(&quot;ATTENDEE:&quot;).append(attendee).append(&quot;\n&quot;);&#10;        }&#10;        sb.append(&quot;END:VEVENT\n&quot;);&#10;        return sb;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public String getUid() { return uid; }&#10;    public void setUid(String uid) { this.uid = uid; }&#10;    public String getSummary() { return summary; }&#10;    public void setSummary(String summary) { this.summary = summary; }&#10;    public String getDescription() { return description; }&#10;    public void setDescription(String description) { this.description = description; }&#10;    public String getLocation() { return location; }&#10;    public void setLocation(String location) { this.location = location; }&#10;    public java.time.LocalDateTime getStart() { return start; }&#10;    public void setStart(java.time.LocalDateTime start) { this.start = start; }&#10;    public java.time.LocalDateTime getEnd() { return end; }&#10;    public void setEnd(java.time.LocalDateTime end) { this.end = end; }&#10;    public String getOrganizer() { return organizer; }&#10;    public void setOrganizer(String organizer) { this.organizer = organizer; }&#10;    public java.util.List&lt;String&gt; getAttendees() { return attendees; }&#10;    public void setAttendees(java.util.List&lt;String&gt; attendees) { this.attendees = attendees; }&#10;}&#10;" />
              <option name="updatedContent" value="public class MyEvent {&#10;    private String uid;&#10;    private String summary;&#10;    private String description;&#10;    private String location;&#10;    private java.time.LocalDateTime start;&#10;    private java.time.LocalDateTime end;&#10;    private String organizer;&#10;    private java.util.List&lt;String&gt; attendees;&#10;&#10;    public MyEvent(String uid, String summary, String description, String location, java.time.LocalDateTime start, java.time.LocalDateTime end, String organizer, java.util.List&lt;String&gt; attendees) {&#10;        this.uid = uid;&#10;        this.summary = summary;&#10;        this.description = description;&#10;        this.location = location;&#10;        this.start = start;&#10;        this.end = end;&#10;        this.organizer = organizer;&#10;        this.attendees = attendees;&#10;    }&#10;&#10;    public MyEvent() {&#10;        this.attendees = new java.util.ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // Modular iCal field formatting&#10;    private String formatUid() {&#10;        return &quot;UID:&quot; + uid + &quot;\n&quot;;&#10;    }&#10;    private String formatSummary() {&#10;        return &quot;SUMMARY:&quot; + summary + &quot;\n&quot;;&#10;    }&#10;    private String formatDescription() {&#10;        return &quot;DESCRIPTION:&quot; + description + &quot;\n&quot;;&#10;    }&#10;    private String formatLocation() {&#10;        return &quot;LOCATION:&quot; + location + &quot;\n&quot;;&#10;    }&#10;    private String formatStart() {&#10;        return &quot;DTSTART:&quot; + start.format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd'T'HHmmss&quot;)) + &quot;\n&quot;;&#10;    }&#10;    private String formatEnd() {&#10;        return &quot;DTEND:&quot; + end.format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd'T'HHmmss&quot;)) + &quot;\n&quot;;&#10;    }&#10;    private String formatOrganizer() {&#10;        return &quot;ORGANIZER:&quot; + organizer + &quot;\n&quot;;&#10;    }&#10;    private String formatAttendees() {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (String attendee : attendees) {&#10;            sb.append(&quot;ATTENDEE:&quot;).append(attendee).append(&quot;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    // Create iCal format string for the event&#10;    public StringBuilder toICalString(StringBuilder sb) {&#10;        sb.append(&quot;BEGIN:VEVENT\n&quot;);&#10;        sb.append(formatUid());&#10;        sb.append(formatSummary());&#10;        sb.append(formatDescription());&#10;        sb.append(formatLocation());&#10;        sb.append(formatStart());&#10;        sb.append(formatEnd());&#10;        sb.append(formatOrganizer());&#10;        sb.append(formatAttendees());&#10;        sb.append(&quot;END:VEVENT\n&quot;);&#10;        return sb;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public String getUid() { return uid; }&#10;    public void setUid(String uid) { this.uid = uid; }&#10;    public String getSummary() { return summary; }&#10;    public void setSummary(String summary) { this.summary = summary; }&#10;    public String getDescription() { return description; }&#10;    public void setDescription(String description) { this.description = description; }&#10;    public String getLocation() { return location; }&#10;    public void setLocation(String location) { this.location = location; }&#10;    public java.time.LocalDateTime getStart() { return start; }&#10;    public void setStart(java.time.LocalDateTime start) { this.start = start; }&#10;    public java.time.LocalDateTime getEnd() { return end; }&#10;    public void setEnd(java.time.LocalDateTime end) { this.end = end; }&#10;    public String getOrganizer() { return organizer; }&#10;    public void setOrganizer(String organizer) { this.organizer = organizer; }&#10;    public java.util.List&lt;String&gt; getAttendees() { return attendees; }&#10;    public void setAttendees(java.util.List&lt;String&gt; attendees) { this.attendees = attendees; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/ui/controller/Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/ui/controller/Controller.java" />
              <option name="originalContent" value="package ui.controller;&#10;&#10;import ui.view.StartView;&#10;import utils.CalendarApiConnector;&#10;&#10;import java.io.IOException;&#10;import java.security.GeneralSecurityException;&#10;import java.util.Calendar;&#10;&#10;public class Controller {&#10;    private StartView startView;&#10;    private CalendarApiConnector apiConnector;&#10;&#10;    private static Controller instance;&#10;&#10;    /**&#10;     * Private constructor for the Controller class.&#10;     * Initializes the StartView and sets up the API connector.&#10;     */&#10;    private Controller() {&#10;        // Set look and feel&#10;        try {&#10;            javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());&#10;        } catch (Exception e) {&#10;            // Use default look and feel&#10;            System.out.println(&quot;Using default view: Failed to set system look and feel: &quot; + e.getMessage());&#10;        }&#10;        // Initialize the StartView&#10;        // TODO: Implement the logic that the start view should only show if the user is not logged in&#10;        this.startView = new StartView(this);&#10;    }&#10;&#10;    /**&#10;     * Singleton pattern to ensure only one instance of Controller exists.&#10;     *&#10;     * @return The single instance of Controller.&#10;     */&#10;    public static Controller getInstance() {&#10;        if (instance == null) {&#10;            instance = new Controller();&#10;        }&#10;        return instance;&#10;    }&#10;&#10;    public void startLoginProcess() {&#10;        try {&#10;            startView.showLoginPrompt(CalendarApiConnector.getLoginUrl());&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(e);&#10;        }&#10;        try {&#10;            apiConnector = CalendarApiConnector.getInstance();&#10;            // This is called when the OAuth flow completes successfully&#10;            startView.hideView();&#10;            // TODO: Proceed to the main application view or dashboard&#10;        } catch (IOException | GeneralSecurityException e) {&#10;            startView.showErrorDialog(&quot;Error during login process: &quot; + e.getMessage());&#10;            System.err.println(&quot;Error during login process: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void clearCache() {&#10;        // Clear the cache in the CalendarApiConnector&#10;        try {&#10;            CalendarApiConnector.clearCredentials();&#10;            startView.showClearCacheSuccess();&#10;        } catch (IOException e) {&#10;            startView.showErrorDialog(&quot;Failed to clear cache: &quot; + e.getMessage());&#10;            System.err.println(&quot;Failed to clear cache: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package ui.controller;&#10;&#10;import ui.view.StartView;&#10;import utils.CalendarApiConnector;&#10;&#10;import java.io.IOException;&#10;import java.security.GeneralSecurityException;&#10;import java.util.Calendar;&#10;import javax.swing.SwingUtilities;&#10;&#10;public class Controller {&#10;    private StartView startView;&#10;    private CalendarApiConnector apiConnector;&#10;&#10;    private static Controller instance;&#10;&#10;    /**&#10;     * Private constructor for the Controller class.&#10;     * Initializes the StartView and sets up the API connector.&#10;     */&#10;    private Controller() {&#10;        // Set look and feel&#10;        try {&#10;            javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());&#10;        } catch (Exception e) {&#10;            // Use default look and feel&#10;            System.out.println(&quot;Using default view: Failed to set system look and feel: &quot; + e.getMessage());&#10;        }&#10;        // Initialize the StartView&#10;        // TODO: Implement the logic that the start view should only show if the user is not logged in&#10;        this.startView = new StartView(this);&#10;    }&#10;&#10;    /**&#10;     * Singleton pattern to ensure only one instance of Controller exists.&#10;     *&#10;     * @return The single instance of Controller.&#10;     */&#10;    public static Controller getInstance() {&#10;        if (instance == null) {&#10;            instance = new Controller();&#10;        }&#10;        return instance;&#10;    }&#10;&#10;    public void startLoginProcess() {&#10;        try {&#10;            startView.showLoginPrompt(CalendarApiConnector.getLoginUrl());&#10;            &#10;            // Start OAuth flow in a separate thread after a small delay to allow UI to render&#10;            SwingUtilities.invokeLater(() -&gt; {&#10;                new Thread(() -&gt; {&#10;                    try {&#10;                        // Small delay to ensure the login dialog is fully rendered&#10;                        Thread.sleep(500);&#10;                        &#10;                        apiConnector = CalendarApiConnector.getInstance();&#10;                        // This is called when the OAuth flow completes successfully&#10;                        SwingUtilities.invokeLater(() -&gt; {&#10;                            startView.hideView();&#10;                            // TODO: Proceed to the main application view or dashboard&#10;                        });&#10;                    } catch (IOException | GeneralSecurityException e) {&#10;                        SwingUtilities.invokeLater(() -&gt; {&#10;                            startView.showErrorDialog(&quot;Error during login process: &quot; + e.getMessage());&#10;                        });&#10;                        System.err.println(&quot;Error during login process: &quot; + e.getMessage());&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        System.err.println(&quot;Login process was interrupted: &quot; + e.getMessage());&#10;                    }&#10;                }).start();&#10;            });&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(e);&#10;        }&#10;    }&#10;&#10;    public void clearCache() {&#10;        // Clear the cache in the CalendarApiConnector&#10;        try {&#10;            CalendarApiConnector.clearCredentials();&#10;            startView.showClearCacheSuccess();&#10;        } catch (IOException e) {&#10;            startView.showErrorDialog(&quot;Failed to clear cache: &quot; + e.getMessage());&#10;            System.err.println(&quot;Failed to clear cache: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/ui/model/CalendarModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/ui/model/CalendarModel.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package ui.model;&#10;&#10;import com.google.api.client.util.DateTime;&#10;import com.google.api.services.calendar.model.Events;&#10;&#10;import java.util.Observable;&#10;&#10;/**&#10; * Simplified Model class for the Calendar application following MVC pattern.&#10; * This class holds the application state and notifies observers when data changes.&#10; * The business logic is handled by the existing G2iCal infrastructure in the controller.&#10; */&#10;@SuppressWarnings(&quot;deprecation&quot;)&#10;public class CalendarModel extends Observable {&#10;    private String selectedCalendarId;&#10;    private DateTime startDate;&#10;    private DateTime endDate;&#10;    private String fileName;&#10;    private Events fetchedEvents;&#10;    private String status;&#10;&#10;    public CalendarModel() {&#10;        this.status = &quot;Ready&quot;;&#10;    }&#10;&#10;    // Getters and setters with notification&#10;    public String getSelectedCalendarId() {&#10;        return selectedCalendarId;&#10;    }&#10;&#10;    public void setSelectedCalendarId(String selectedCalendarId) {&#10;        this.selectedCalendarId = selectedCalendarId;&#10;        setChanged();&#10;        notifyObservers(&quot;calendarSelected&quot;);&#10;    }&#10;&#10;    public DateTime getStartDate() {&#10;        return startDate;&#10;    }&#10;&#10;    public void setStartDate(DateTime startDate) {&#10;        this.startDate = startDate;&#10;        setChanged();&#10;        notifyObservers(&quot;startDateChanged&quot;);&#10;    }&#10;&#10;    public DateTime getEndDate() {&#10;        return endDate;&#10;    }&#10;&#10;    public void setEndDate(DateTime endDate) {&#10;        this.endDate = endDate;&#10;        setChanged();&#10;        notifyObservers(&quot;endDateChanged&quot;);&#10;    }&#10;&#10;    public String getFileName() {&#10;        return fileName;&#10;    }&#10;&#10;    public void setFileName(String fileName) {&#10;        this.fileName = fileName;&#10;        setChanged();&#10;        notifyObservers(&quot;fileNameChanged&quot;);&#10;    }&#10;&#10;    public Events getFetchedEvents() {&#10;        return fetchedEvents;&#10;    }&#10;&#10;    public void setFetchedEvents(Events fetchedEvents) {&#10;        this.fetchedEvents = fetchedEvents;&#10;        setChanged();&#10;        notifyObservers(&quot;eventsChanged&quot;);&#10;    }&#10;&#10;    public String getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public void setStatus(String status) {&#10;        this.status = status;&#10;        setChanged();&#10;        notifyObservers(&quot;statusChanged&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>